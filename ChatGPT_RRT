# üöÄ RRT.py - Dynamic RRT planner con controllo collisioni migliorato

import random
import math

class RRT:
    def __init__(self, map_obj, max_iter=500, step_size=0.5):
        self.map = map_obj  # Oggetto della mappa occupata
        self.max_iter = max_iter  # Numero massimo di iterazioni
        self.step_size = step_size  # Lunghezza massima di un passo RRT
        self.nodes = [self.map.start]  # Lista dei nodi esplorati (inizia da start)
        self.parent = {self.map.start: None}  # Albero padre (per ricostruire path)

    def plan(self):
        goal = self.map.goal
        for _ in range(self.max_iter):
            q_rand = self.sample_random_config()
            q_near = self.nearest(q_rand)
            q_new = self.steer(q_near, q_rand)

            if not self.map.check_collision(q_new):
                if self.map.collision_free([q_near, q_new]):
                    self.nodes.append(q_new)
                    self.parent[q_new] = q_near

                    if self.reached_goal(q_new, goal):
                        print("üéØ Goal reached!")
                        return self.reconstruct_path(q_new)
        print("‚ùå No valid path found!")
        return []

    def sample_random_config(self):
        # Estrai punto casuale nel dominio della mappa (spazio continuo)
        x = random.uniform(self.map.origin.position.x, self.map.origin.position.x + self.map.width * self.map.resolution)
        y = random.uniform(self.map.origin.position.y, self.map.origin.position.y + self.map.height * self.map.resolution)
        theta = random.uniform(-math.pi, math.pi)
        return (x, y, theta)

    def nearest(self, q_rand):
        # Ritorna il nodo pi√π vicino a q_rand nella lista attuale dei nodi
        return min(self.nodes, key=lambda q: self.distance(q, q_rand))

    def steer(self, q_near, q_rand):
        # Direzione tra i due punti
        dx = q_rand[0] - q_near[0]
        dy = q_rand[1] - q_near[1]
        dist = math.hypot(dx, dy)
        theta = math.atan2(dy, dx)

        # Limita il passo massimo
        dist = min(self.step_size, dist)

        x_new = q_near[0] + dist * math.cos(theta)
        y_new = q_near[1] + dist * math.sin(theta)
        theta_new = theta

        return (x_new, y_new, theta_new)

    def distance(self, q1, q2):
        return math.hypot(q1[0] - q2[0], q1[1] - q2[1])

    def reached_goal(self, q_new, goal):
        # Se siamo abbastanza vicini al goal, consideriamo raggiunto
        return self.distance(q_new, goal) < self.step_size

    def reconstruct_path(self, end):
        # Ricostruisce path a ritroso dai parent
        path = [end]
        while self.parent[end] is not None:
            end = self.parent[end]
            path.append(end)
        return path[::-1]  # Inverte per ottenere start -> goal

